<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jeu : Le Pont (Hashi)</title>
    <style>
        body { font-family: 'Arial', sans-serif; display: flex; flex-direction: column; align-items: center; background-color: #f0f8ff; }
        .game-area { position: relative; margin: 1rem auto; }
        .island { position: absolute; background-color: #f0e68c; border: 2px solid #daa520; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 1.5rem; font-weight: bold; cursor: pointer; user-select: none; z-index: 2; }
        .island.completed { border-color: #32cd32; color: #228b22; }
        .bridge { position: absolute; background-color: #8b4513; z-index: 1; cursor: pointer; }
        .bridge:hover { background-color: #a0522d; }
        .bridge.double::after { content: ''; position: absolute; top: 3px; bottom: 3px; left: 0; right: 0; background: #8b4513; }
        .controls button, .controls a { font-size: 1rem; padding: 0.5rem 1rem; margin: 0.5rem; border-radius: 5px; border: 1px solid #ccc; cursor: pointer; }
        #message-box { height: 2rem; font-weight: bold; }
    </style>
</head>
<body>
    <h1>Jeu du Pont (Hashi)</h1>
    <p>Connectez les îles avec le bon nombre de ponts. Les ponts ne peuvent pas se croiser.</p>
    <div id="game-container" class="game-area">
        <!-- Le jeu sera généré ici -->
    </div>
    <div id="message-box"></div>
    <div class="controls">
        <button id="reset-button" class="button">Recommencer</button>
        <a href="../index.html" class="button" style="text-decoration: none; background-color: #4a5568; color: white;">Accueil</a>
    </div>
    <footer style="margin-top: 2rem; color: #718096;">Créé par Chrice</footer>
    <script>
        // NOTE: Ce jeu est une implémentation simplifiée. La logique complète de Hashi (validation de croisement, etc.) est très complexe.
        document.addEventListener('DOMContentLoaded', () => {
            const gameContainer = document.getElementById('game-container');
            const resetButton = document.getElementById('reset-button');
            const messageBox = document.getElementById('message-box');

            const puzzle = [ // r, c, connections
                [1, 1, 2], [1, 4, 3], [1, 6, 1],
                [3, 0, 2], [3, 2, 5], [3, 4, 4], [3, 6, 2],
                [5, 1, 3], [5, 3, 3], [5, 5, 1]
            ];
            const CELL_SIZE = 60;
            const ISLAND_SIZE = 50;
            let islands = [];
            let bridges = {};
            let selectedIsland = null;

            function drawGame() {
                gameContainer.innerHTML = '';
                islands = [];
                bridges = {};
                messageBox.textContent = '';
                
                const width = Math.max(...puzzle.map(p => p[1])) + 2;
                const height = Math.max(...puzzle.map(p => p[0])) + 2;
                gameContainer.style.width = `${width * CELL_SIZE}px`;
                gameContainer.style.height = `${height * CELL_SIZE}px`;

                puzzle.forEach((p, index) => {
                    const [r, c, connections] = p;
                    const island = document.createElement('div');
                    island.className = 'island';
                    island.id = `island-${index}`;
                    island.textContent = connections;
                    island.style.width = `${ISLAND_SIZE}px`;
                    island.style.height = `${ISLAND_SIZE}px`;
                    island.style.top = `${r * CELL_SIZE + (CELL_SIZE - ISLAND_SIZE) / 2}px`;
                    island.style.left = `${c * CELL_SIZE + (CELL_SIZE - ISLAND_SIZE) / 2}px`;
                    
                    const islandData = { id: index, r, c, connections, current: 0, element: island };
                    islands.push(islandData);
                    
                    island.addEventListener('click', () => onIslandClick(islandData));
                    gameContainer.appendChild(island);
                });
            }
            
            function onIslandClick(islandData) {
                if (!selectedIsland) {
                    selectedIsland = islandData;
                    islandData.element.style.borderColor = 'gold';
                } else if (selectedIsland.id === islandData.id) {
                    selectedIsland.element.style.borderColor = '#daa520';
                    selectedIsland = null;
                } else {
                    // Tenter de construire un pont
                    if (selectedIsland.r === islandData.r || selectedIsland.c === islandData.c) {
                        drawBridge(selectedIsland, islandData);
                    }
                    selectedIsland.element.style.borderColor = '#daa520';
                    selectedIsland = null;
                }
            }

            function drawBridge(island1, island2) {
                const bridgeId = [island1.id, island2.id].sort().join('-');
                
                if (bridges[bridgeId] && bridges[bridgeId].count >= 2) {
                    // Supprimer le pont
                    bridges[bridgeId].element.remove();
                    island1.current -= bridges[bridgeId].count;
                    island2.current -= bridges[bridgeId].count;
                    delete bridges[bridgeId];
                } else {
                    let count = 1;
                    if (bridges[bridgeId]) {
                        count = 2;
                        bridges[bridgeId].element.remove();
                    }
                    
                    const bridgeEl = document.createElement('div');
                    bridgeEl.className = 'bridge';
                    if (count === 2) bridgeEl.classList.add('double');

                    if (island1.r === island2.r) { // Horizontal
                        bridgeEl.style.top = `${island1.r * CELL_SIZE + (CELL_SIZE - 8) / 2}px`;
                        bridgeEl.style.left = `${Math.min(island1.c, island2.c) * CELL_SIZE + ISLAND_SIZE / 2}px`;
                        bridgeEl.style.width = `${Math.abs(island1.c - island2.c) * CELL_SIZE - ISLAND_SIZE}px`;
                        bridgeEl.style.height = `8px`;
                    } else { // Vertical
                        bridgeEl.style.left = `${island1.c * CELL_SIZE + (CELL_SIZE - 8) / 2}px`;
                        bridgeEl.style.top = `${Math.min(island1.r, island2.r) * CELL_SIZE + ISLAND_SIZE / 2}px`;
                        bridgeEl.style.height = `${Math.abs(island1.r - island2.r) * CELL_SIZE - ISLAND_SIZE}px`;
                        bridgeEl.style.width = `8px`;
                    }
                    
                    if (bridges[bridgeId]) {
                        island1.current += 1;
                        island2.current += 1;
                    } else {
                        island1.current += 1;
                        island2.current += 1;
                    }
                    
                    bridges[bridgeId] = { element: bridgeEl, count: count };
                    gameContainer.appendChild(bridgeEl);
                }
                updateIslandStatus();
            }
            
            function updateIslandStatus() {
                let allCompleted = true;
                islands.forEach(island => {
                    if (island.current === island.connections) {
                        island.element.classList.add('completed');
                    } else {
                        island.element.classList.remove('completed');
                        allCompleted = false;
                    }
                });
                if (allCompleted) {
                    messageBox.textContent = "Bravo, puzzle résolu !";
                    messageBox.style.color = "green";
                }
            }

            resetButton.addEventListener('click', drawGame);
            drawGame();
        });
    </script>
</body>
</html>
